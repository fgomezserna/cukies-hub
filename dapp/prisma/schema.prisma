// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  walletAddress     String  @unique
  username          String? @unique
  isUsernameSet     Boolean @default(false)
  email             String?
  profilePictureUrl String?
  bio               String? @db.String
  xp                Int     @default(0)

  // Socials
  twitterHandle     String?
  twitterName       String?  // Nombre completo de Twitter
  twitterId         String?  // ID de Twitter
  discordUsername   String?
  telegramUsername  String?

  // Quest progress
  completedQuests UserQuest[]

  // Daily Check-in
  dailyCheckIns DailyCheckIn[]
  lastCheckIn   Streak?

  // Referrals
  referralCode    String?
  referredById    String? @db.ObjectId
  referredBy      User?   @relation("Referrals", fields: [referredById], references: [id], onDelete: NoAction, onUpdate: NoAction)
  referrals       User[]  @relation("Referrals")
  referralRewards Int     @default(0)

  // Point transactions history
  pointTransactions PointTransaction[]

  // Game sessions and results
  gameSessions GameSession[]
  gameResults  GameResult[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation to tasks completed by the user
  completedTasks UserCompletedTask[]

  // NextAuth relations
  accounts Account[]
  sessions Session[]
  
  // Chat relations
  chatMessages    ChatMessage[]
  chatRoomMembers ChatRoomMember[]
}

// Game Session model
model GameSession {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken  String   @unique
  sessionId     String   @unique
  userId        String   @db.ObjectId
  user          User     @relation(fields: [userId], references: [id])
  gameId        String   // e.g., 'sybil-slayer', 'hyppie-road'
  gameVersion   String?
  startedAt     DateTime @default(now())
  endedAt       DateTime?
  isActive      Boolean  @default(true)
  
  // Checkpoints during the session
  checkpoints   GameCheckpoint[]
  
  // Final result
  result        GameResult?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, gameId])
}

// Game Checkpoint model
model GameCheckpoint {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionId     String   @db.ObjectId
  session       GameSession @relation(fields: [sessionId], references: [id])
  score         Int
  gameTime      Int      // Time in milliseconds
  timestamp     DateTime @default(now())
  nonce         String?  // For security validation
  hash          String?  // For security validation
  events        Json?    // Array of events that happened
  
  createdAt DateTime @default(now())

  @@index([sessionId, timestamp])
}

// Game Result model
model GameResult {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionId     String   @unique @db.ObjectId
  session       GameSession @relation(fields: [sessionId], references: [id])
  userId        String   @db.ObjectId
  user          User     @relation(fields: [userId], references: [id])
  gameId        String
  finalScore    Int
  gameTime      Int      // Total time played in milliseconds
  metadata      Json?    // Additional game data (level, hearts, etc.)
  isValid       Boolean  @default(true)
  xpEarned      Int      @default(0)
  
  createdAt DateTime @default(now())

  @@index([userId, gameId])
  @@index([finalScore])
}

model Streak {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String   @unique @db.ObjectId
  user        User     @relation(fields: [userId], references: [id])
  days        Int      @default(0)
  lastCheckIn DateTime
}

model DailyCheckIn {
  id       String   @id @default(auto()) @map("_id") @db.ObjectId
  userId   String   @db.ObjectId
  user     User     @relation(fields: [userId], references: [id])
  date     DateTime @default(now())
  xpGained Int
}

model Quest {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  title       String
  description String?
  imageUrl    String?
  xp          Int
  isStarter   Boolean? @default(false)

  tasks       Task[]
  completedBy UserQuest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Task {
  id                    String  @id @default(auto()) @map("_id") @db.ObjectId
  title                 String
  description           String?
  validationApiEndpoint String?

  questId String @db.ObjectId
  quest   Quest  @relation(fields: [questId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation to users who completed this task
  completedBy UserCompletedTask[]
}

model UserQuest {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String   @db.ObjectId
  user        User     @relation(fields: [userId], references: [id])
  questId     String   @db.ObjectId
  quest       Quest    @relation(fields: [questId], references: [id])
  completedAt DateTime @default(now())

  @@unique([userId, questId])
}

// New model to track completion of individual tasks
model UserCompletedTask {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id])
  taskId    String   @db.ObjectId
  task      Task     @relation(fields: [taskId], references: [id])
  completedAt DateTime @default(now())

  @@unique([userId, taskId])
}

// New model to track all point transactions (earned and spent)
model PointTransaction {
  id          String             @id @default(auto()) @map("_id") @db.ObjectId
  userId      String             @db.ObjectId
  user        User               @relation(fields: [userId], references: [id])
  amount      Int                // Positive for earned, negative for spent
  type        PointTransactionType
  reason      String             // Description of why points were gained/lost
  metadata    Json?              // Additional data (quest id, game id, etc.)
  createdAt   DateTime           @default(now())

  @@index([userId, createdAt])
}

enum PointTransactionType {
  QUEST_COMPLETION
  DAILY_LOGIN
  GAME_PLAY
  GAME_WIN
  REFERRAL_BONUS
  REFERRAL_LEVEL_1
  REFERRAL_LEVEL_2
  PURCHASE
  MANUAL_ADJUSTMENT
  OTHER
}

/// --- NEXTAUTH MODELS (required for Prisma Adapter) ---
model Account {
  id                 String  @id @default(auto()) @map("_id") @db.ObjectId
  userId             String  @db.ObjectId
  user               User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  id_token           String?
  scope              String?
  session_state      String?
  token_type         String?
  oauth_token        String?
  oauth_token_secret String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([userId])
  @@unique([provider, providerAccountId])
}

model Session {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken  String   @unique
  userId        String   @db.ObjectId
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires       DateTime

  @@index([userId])
}

model VerificationToken {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier  String
  token       String   @unique
  expires     DateTime

  @@index([identifier])
}

// Model to track Twitter followers from IFTTT webhook
model TwitterFollower {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  twitterUsername String   @unique // Twitter username without @
  twitterHandle   String   // Twitter handle (same as username, for consistency)
  twitterName     String?  // Display name from Twitter
  followedAt      DateTime @default(now())
  
  // For debugging and webhook verification
  webhookData     Json?    // Raw data from IFTTT webhook
}

// Game Configuration model
model Game {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  gameId        String   @unique  // e.g., 'sybil-slayer', 'hyppie-road'
  name          String   // Display name: 'Sybil Slayer', 'Hyppie Road'
  description   String   // Game description
  emoji         String?  // Game emoji/icon
  gameUrl       String   // URL to the game iframe
  port          Int?     // Development port
  
  // Game-specific ranks
  ranks         Json     // Array of rank objects with xp thresholds
  
  // UI Configuration
  leaderboardTitle String // e.g., 'Top Slayers', 'Top Riders'
  playInstructions Json?  // Array of instruction objects
  
  // Game status
  isActive      Boolean  @default(true)
  isInMaintenance Boolean @default(false)
  
  // Metadata
  version       String?  @default("1.0.0")
  category      String?  // 'arcade', 'strategy', 'betting', etc.
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([gameId, isActive])
}

// Chat models for game-specific chat rooms
model ChatRoom {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  gameId        String   // 'sybil-slayer', 'hyppie-road', etc.
  name          String   // Display name for the chat room
  description   String?  // Optional description
  
  // Telegram integration
  telegramTopicId  Int?  // Topic ID in Telegram group
  telegramGroupId  String? // Telegram group chat ID
  
  // Settings
  isActive      Boolean  @default(true)
  maxMembers    Int?     // Optional member limit
  
  // Relations
  messages      ChatMessage[]
  members       ChatRoomMember[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@unique([gameId])
  @@index([gameId, isActive])
}

model ChatMessage {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  roomId        String   @db.ObjectId
  room          ChatRoom @relation(fields: [roomId], references: [id])
  
  // Message content
  content       String
  messageType   MessageType @default(TEXT)
  
  // Author information
  userId        String?  @db.ObjectId
  user          User?    @relation(fields: [userId], references: [id])
  
  // For messages from Telegram users not in our system
  telegramUserId     Int?
  telegramUsername   String?
  telegramFirstName  String?
  telegramLastName   String?
  
  // Telegram message info
  telegramMessageId  Int?     // Original message ID from Telegram
  
  // Message metadata
  isFromTelegram    Boolean  @default(false)
  isFromWeb         Boolean  @default(false)
  isEdited          Boolean  @default(false)
  isDeleted         Boolean  @default(false)
  
  // Reply functionality
  replyToId     String?  @db.ObjectId
  replyTo       ChatMessage? @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies       ChatMessage[] @relation("MessageReplies")
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([roomId, createdAt])
  @@index([userId, createdAt])
  @@index([telegramMessageId])
}

model ChatRoomMember {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  roomId        String   @db.ObjectId
  room          ChatRoom @relation(fields: [roomId], references: [id])
  userId        String   @db.ObjectId
  user          User     @relation(fields: [userId], references: [id])
  
  // Member status
  role          ChatRole @default(MEMBER)
  isActive      Boolean  @default(true)
  isMuted       Boolean  @default(false)
  
  // Timestamps
  joinedAt      DateTime @default(now())
  lastSeenAt    DateTime @default(now())
  
  @@unique([roomId, userId])
  @@index([userId, isActive])
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  STICKER
  SYSTEM
}

enum ChatRole {
  MEMBER
  MODERATOR
  ADMIN
}
